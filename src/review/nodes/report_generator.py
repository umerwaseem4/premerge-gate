"""Report generator node - creates Markdown and DOCX reports."""

from __future__ import annotations

import os
from datetime import datetime
from io import BytesIO
from pathlib import Path
from typing import List, Optional

from docx import Document
from docx.shared import Pt, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH

from src.review.state import PRInfo, ReviewFinding, ReviewState, Severity, Category


def generate_markdown_report(state: ReviewState, artifact_url: Optional[str] = None) -> str:
    """Generate a Markdown report for GitHub PR comment.

    Args:
        state: The review state with all findings.
        artifact_url: Optional URL to the downloadable DOCX report.

    Returns:
        Markdown-formatted report string.
    """
    decision = state.get("decision", "UNKNOWN")
    findings = state.get("findings", [])
    pr_info = state.get("pr_metadata")
    confidence = state.get("confidence_score", 0)

    # Group findings by severity
    blocking = [f for f in findings if f.severity == Severity.BLOCKING]
    non_blocking = [f for f in findings if f.severity == Severity.NON_BLOCKING]
    suggestions = [f for f in findings if f.severity == Severity.SUGGESTION]

    # Professional header without emojis
    if decision == "PASS":
        header = "## AI Staff Review: PASSED"
    elif decision == "FAIL":
        header = "## AI Staff Review: FAILED"
    else:
        header = "## AI Staff Review: ERROR"

    lines = [header, ""]

    # Summary section
    lines.append("### Summary")
    lines.append(state.get("intent_summary", "No summary available."))
    lines.append("")

    # Blocking issues
    if blocking:
        lines.append(f"### Blocking Issues ({len(blocking)})")
        lines.append("")
        lines.append("| # | File | Issue | Category |")
        lines.append("|---|------|-------|----------|")
        for i, finding in enumerate(blocking, 1):
            file_loc = finding.file_path or "N/A"
            if finding.line_start:
                file_loc += f":{finding.line_start}"
            lines.append(
                f"| {i} | `{file_loc}` | {finding.title} | {finding.category.value} |"
            )
        lines.append("")

        # Detailed explanations
        lines.append("<details>")
        lines.append("<summary>View detailed explanations</summary>")
        lines.append("")
        for i, finding in enumerate(blocking, 1):
            lines.append(f"#### {i}. {finding.title}")
            lines.append("")
            lines.append(finding.description)
            if finding.code_snippet:
                lines.append("")
                lines.append("```")
                lines.append(finding.code_snippet)
                lines.append("```")
            if finding.suggested_fix:
                lines.append("")
                lines.append(f"**Suggested fix:** {finding.suggested_fix}")
            lines.append("")
        lines.append("</details>")
        lines.append("")

    # Non-blocking issues
    if non_blocking:
        lines.append(f"### Non-Blocking Issues ({len(non_blocking)})")
        lines.append("")
        lines.append("| # | File | Issue |")
        lines.append("|---|------|-------|")
        for i, finding in enumerate(non_blocking, 1):
            file_loc = finding.file_path or "N/A"
            if finding.line_start:
                file_loc += f":{finding.line_start}"
            lines.append(f"| {i} | `{file_loc}` | {finding.title} |")
        lines.append("")

    # Suggestions (collapsed)
    if suggestions:
        lines.append("<details>")
        lines.append(f"<summary>Suggestions ({len(suggestions)})</summary>")
        lines.append("")
        for finding in suggestions:
            lines.append(f"- **{finding.title}**: {finding.description}")
        lines.append("")
        lines.append("</details>")
        lines.append("")

    # If no issues at all
    if not findings:
        lines.append("### No Issues Found")
        lines.append("")
        lines.append("This PR passed all automated review checks.")
        lines.append("")

    # Footer
    lines.append("---")
    lines.append(f"**Confidence:** {confidence:.0%}")

    if artifact_url:
        lines.append("")
        lines.append(f"**[Download Full Report (DOCX)]({artifact_url})**")

    lines.append("")
    lines.append("*This review was generated by AI. Re-run triggered automatically on new commits.*")

    return "\n".join(lines)


def generate_docx_report(state: ReviewState) -> bytes:
    """Generate a Word document report.

    Args:
        state: The review state with all findings.

    Returns:
        The DOCX file as bytes.
    """
    doc = Document()

    pr_info = state.get("pr_metadata")
    decision = state.get("decision", "UNKNOWN")
    findings = state.get("findings", [])
    confidence = state.get("confidence_score", 0)

    # Title
    title = doc.add_heading("Code Review Report", 0)
    title.alignment = WD_ALIGN_PARAGRAPH.CENTER

    # Subtitle with PR info
    if pr_info:
        subtitle = doc.add_paragraph()
        subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = subtitle.add_run(f"Pull Request #{pr_info.number}: {pr_info.title}")
        run.font.size = Pt(14)
        run.font.color.rgb = RGBColor(100, 100, 100)

    # Date
    date_para = doc.add_paragraph()
    date_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
    date_para.add_run(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

    doc.add_paragraph()

    # Decision box - professional without emojis
    decision_para = doc.add_paragraph()
    decision_text = "PASSED" if decision == "PASS" else "FAILED"
    decision_run = decision_para.add_run(f"Review Decision: {decision_text}")
    decision_run.font.size = Pt(16)
    decision_run.font.bold = True
    if decision == "PASS":
        decision_run.font.color.rgb = RGBColor(0, 128, 0)
    else:
        decision_run.font.color.rgb = RGBColor(192, 0, 0)

    doc.add_paragraph(f"Confidence Score: {confidence:.0%}")
    doc.add_paragraph()

    # Executive Summary
    doc.add_heading("Executive Summary", level=1)
    doc.add_paragraph(state.get("intent_summary", "No summary available."))

    # PR Information
    if pr_info:
        doc.add_heading("Pull Request Information", level=1)
        info_table = doc.add_table(rows=6, cols=2)
        info_table.style = "Table Grid"

        info_data = [
            ("PR Number", f"#{pr_info.number}"),
            ("Author", pr_info.author),
            ("Target Branch", pr_info.base_branch),
            ("Source Branch", pr_info.head_branch),
            ("Files Changed", str(len(pr_info.files_changed))),
            ("Changes", f"+{pr_info.additions} / -{pr_info.deletions}"),
        ]

        for i, (label, value) in enumerate(info_data):
            row = info_table.rows[i]
            row.cells[0].text = label
            row.cells[1].text = value
            row.cells[0].paragraphs[0].runs[0].font.bold = True

    doc.add_paragraph()

    # Group findings
    blocking = [f for f in findings if f.severity == Severity.BLOCKING]
    non_blocking = [f for f in findings if f.severity == Severity.NON_BLOCKING]
    suggestions = [f for f in findings if f.severity == Severity.SUGGESTION]

    # Blocking Issues
    if blocking:
        doc.add_heading("Blocking Issues", level=1)
        doc.add_paragraph(
            "These issues must be resolved before merging. They represent critical bugs, "
            "security vulnerabilities, or production risks."
        )

        for i, finding in enumerate(blocking, 1):
            doc.add_heading(f"{i}. {finding.title}", level=2)

            # Issue details table
            table = doc.add_table(rows=4, cols=2)
            table.style = "Table Grid"

            line_info = str(finding.line_start or "N/A")
            if finding.line_end:
                line_info += f"-{finding.line_end}"

            details = [
                ("Category", finding.category.value.replace("_", " ").title()),
                ("File", finding.file_path or "N/A"),
                ("Line", line_info),
                ("Confidence", f"{finding.confidence:.0%}"),
            ]

            for j, (label, value) in enumerate(details):
                row = table.rows[j]
                row.cells[0].text = label
                row.cells[1].text = value
                row.cells[0].paragraphs[0].runs[0].font.bold = True

            doc.add_paragraph()
            doc.add_paragraph("Description:").runs[0].font.bold = True
            doc.add_paragraph(finding.description)

            if finding.code_snippet:
                doc.add_paragraph("Problematic Code:").runs[0].font.bold = True
                code_para = doc.add_paragraph()
                code_run = code_para.add_run(finding.code_snippet)
                code_run.font.name = "Courier New"
                code_run.font.size = Pt(9)

            if finding.suggested_fix:
                doc.add_paragraph("Suggested Fix:").runs[0].font.bold = True
                doc.add_paragraph(finding.suggested_fix)

            doc.add_paragraph()

    # Non-blocking Issues
    if non_blocking:
        doc.add_heading("Non-Blocking Issues", level=1)
        doc.add_paragraph(
            "These issues should be addressed but do not block the merge. "
            "Consider fixing them in a follow-up PR."
        )

        for i, finding in enumerate(non_blocking, 1):
            doc.add_heading(f"{i}. {finding.title}", level=2)
            doc.add_paragraph(finding.description)
            if finding.suggested_fix:
                fix_para = doc.add_paragraph()
                fix_para.add_run("Fix: ").font.bold = True
                fix_para.add_run(finding.suggested_fix)
            doc.add_paragraph()

    # Suggestions
    if suggestions:
        doc.add_heading("Suggestions", level=1)
        doc.add_paragraph("Optional improvements that could enhance code quality:")

        for finding in suggestions:
            bullet = doc.add_paragraph(style="List Bullet")
            bullet.add_run(f"{finding.title}: ").font.bold = True
            bullet.add_run(finding.description)

    # No issues
    if not findings:
        doc.add_heading("Review Results", level=1)
        doc.add_paragraph(
            "No issues were found during the automated review. "
            "This PR appears to follow best practices and is ready for human review."
        )

    # Footer
    doc.add_paragraph()
    doc.add_paragraph("-" * 60)
    footer = doc.add_paragraph()
    footer.add_run(
        "This report was generated by the AI Code Review system. "
        "It is intended to assist human reviewers and should not be considered a complete review."
    ).font.italic = True

    # Save to bytes
    buffer = BytesIO()
    doc.save(buffer)
    buffer.seek(0)
    return buffer.getvalue()


def save_docx_report(state: ReviewState, output_dir: str = "reports") -> str:
    """Save the DOCX report to a file.

    Args:
        state: The review state with all findings.
        output_dir: Directory to save the report.

    Returns:
        Path to the saved report file.
    """
    # Create output directory
    Path(output_dir).mkdir(parents=True, exist_ok=True)

    # Generate filename
    pr_info = state.get("pr_metadata")
    pr_num = pr_info.number if pr_info else "unknown"
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"code_review_pr{pr_num}_{timestamp}.docx"
    filepath = os.path.join(output_dir, filename)

    # Generate and save
    docx_bytes = generate_docx_report(state)
    with open(filepath, "wb") as f:
        f.write(docx_bytes)

    return filepath


async def report_generator(state: ReviewState) -> dict:
    """Generate both Markdown and DOCX reports.

    Args:
        state: The review state with all findings.

    Returns:
        Updated state with report paths.
    """
    # Save DOCX report
    docx_path = save_docx_report(state)

    # Generate Markdown (artifact URL will be added by main.py)
    markdown_report = generate_markdown_report(state)

    return {
        "markdown_report": markdown_report,
        "docx_report_path": docx_path,
        "current_stage": "report_generator",
    }
